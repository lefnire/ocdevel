[00:00:00] Welcome back to Machine Learning Applied. This is episode 22, code ai. Now Bait and Switch. The real title of this episode is Vibe Coding. Yes, that's right. You landed yourself on accident on an episode about Vibe Coding. Now, why didn't I call the episode Vibe coding then? It's because the phrase vibe Coding has a bad rap, and I'm trying to maintain professional decorum here.

[00:00:25] After all, teaching machine learning in podcast form.

[00:00:28] But I do want to justify the concept of vibe coding and the phrase in a bit. But first, you're here with Machine Learning Guide a podcast series whose goal is to teach you machine learning. Why am I covering? Programming tools presumably to be used with web development and mobile app development and such?

[00:00:47] There's a couple reasons. One is AI to help generate code is not ignorable If you're not using this in your work already, you should be Because it's gonna be a competitive advantage going forward. In In fact, I see job postings now whose description references, vibe coding.

[00:01:03] There's a YouTube video I saw recently, somebody teaching how to use Cursor with aider combined, and the guy was just screaming fast, just plowing through building out a website and. He had one screen in Cursor where he was typing out the requirements for the features that then were being built out by the large language models.

[00:01:25] And another screen he had er, which was watching for new tests being generated by the LLM and would run them in real time in CLI and try to fix any bugs that resulted from the. Generated code


[00:01:37] and watching this guy move so fast, it really was an eye-opener about what we as developers whether app developers or machine learning engineers are up against. If we don't keep up with the tooling of the time, things are changing. My friends. The tooling is getting more sophisticated by way of artificial intelligence.

[00:01:56] If you've been following this series, you knew it was coming. It is here now. So I strongly encourage you if you haven't started using plugin, IDE tool. That you start becoming acquainted with the technology because it is quite sophisticated. In the next episode I'll talk about some of the more advanced tooling and techniques around vibe coding.

[00:02:18] in this episode, I'll just compare some of the tools. So you wanna start getting familiar. The second reason I'm bringing this up in machine learning guide is because you can actually use it for machine learning engineering, and I'll talk about that in the next episode.

[00:02:31] But I have used it, in fact, for generating models. It's almost a spin on auto ml. You can give it some information about your dataset, some of the distributions, some of the shapes you can feed, images of those shapes exported from Jupyter Lab. And have it help you design the right neural network architecture.

[00:02:49] So it's applicable for machine learning engineering specifically. And it's applicable in the domain of machine learning because it uses large language models under the hood. So yeah, that What is vibe coding, that's what it is.

[00:03:00] It's using a large language model. You're familiar with chat, GPT. In your IDEE, either as an IDE itself or as a plugin to an IDE, and you interface with it, by chatting, add this feature, add this unit test, and it will interact with your code base, edit your code and it has all sorts of other features we'll get into in a bit.

[00:03:19] Now let's justify the phrase vibe coding. Like I said, it has a bad rap. It's frowned upon in, in the industry. The phrase, whenever you see that in an article or a blog post or a video, or a expost or an expost it tends to ruffle feathers. Now why is that? Some of this is well deserved. The first and most obvious reason is that people who are professionals in the industry, professional software engineers, machine learning engineers they're not pleased with maybe the haphazard approach with which this tooling is being used. So heavily, so sloppily. Some junior engineers are leaning on it a little too excessively without reviewing the results, before submitting a poll request or a code review.

[00:04:03] And some of these senior engineers are becoming frustrated with the lack of oversight being applied to the output of these tools. Indeed. LLMs suffer in certain areas. There was an article recently that showed that LLMs generally generate less performant code than the average engineer would write at a first pass.


[00:04:25] So if you have it, write something

[00:04:26] that is performance sensitive that you don't want to slow down some part of your app and then it pays to at least review the code and you might have to edit it a fair bit after the fact. So that's reason number one. Is that senior engineers are frustrated with the sort of care that's being tossed to the wind for creating code in this age of LLM. generated code. and in fact, it goes so far that there are some people entering the industry without any experience whatsoever and they're using Vibe coding to generate apps and websites from scratch.

[00:04:59] And then maybe they face some consequences later on when they don't know how to fix the issues that the LLM introduced.

[00:05:06] Now I have two responses to that. as far as a haphazard approach by junior developers, I think the solution is simple. Review your code.

[00:05:14] always look at what's being generated by the LLM before you commit it to Git and with Git as a tool, it makes it very easy to diff the before and after of what the. LLM generated so you can see what it did, and you can make adjustments in, let's say, the right hand pane of a gi Diff before you commit it.

[00:05:33] And as far as newcomers to the industry who've never coded before, and they're using this to generate projects I think that should be encouraged. I think that Vibe Coding is enabling new developers to enter the industry, and all I can say to them is always read what was generated.

[00:05:50] Make sure you become familiar with the languages and the frameworks and the concepts. As you go along through your vibe coding journey, don't just generate code. Commit it to get and call it a day. Make sure, you're always trying to understand what's being generated so you can develop with your project.

[00:06:06] And lastly, Even if these LLMs are sometimes generating poor code, currently, it's only gonna improve. So I think the worry about

[00:06:14] haphazard or sloppy code is just a temporal concern and things are gonna get better. These models are constantly improving. The ides and the plugins are constantly improving. So just make sure you review your code. That's the solution. So that's reason number one for the bad rap reason number two is I think a little bit bigger. This one's got my goat right now. Vibe coding is similar in personality To the cryptocurrency explosion in NFTs, there is just a fire hose of marketing and sales and bait and switch and lies and over promises. What's happening right now is a lot of companies are using vibe coding to generate a website. That Pedals vibe coding.

[00:07:06] So they might use one of these tools to create a website, which is selling a product that is one of these tools, and then they use AI to write the marketing campaign, and they blast it all over Reddit and X and YouTube. You'll see these videos on YouTube that are clearly AI generated.

[00:07:25] The voice is ai. The imagery is ai, and the message is, I didn't know anything about programming and I used vibe coding to generate this project, and overnight I made a million dollars. And it's a flat out lie. and they're trying to sell their service where you too can generate a website overnight and make a million dollars.

[00:07:45] And a lot of people, I've seen people try these tools in fact. a lot of times they're half baked. They're not as sophisticated as some of the tools we'll talk about in this episode. I think that's a legitimate concern. It's feeling like the early cryptocurrency days and NFTs were something just felt wrong and it was being pushed so hard.

[00:08:03] What is going on? I gotta hand it to these people. It's very enterprising. They used AI to create videos and voice and content and marketing and a website. They sure have gusto, but it reflects poorly on the concept of vibe coding which is why I didn't call this episode vibe coding.

[00:08:22] So what's the solution to the marketing hype? Just ignore it. It's a useful tool. I'm going to show you the ropes in this episode of the next. Use the tool to its useful potential and just try to tune out all that million dollars overnight stuff. That's not gonna happen. you're just going to expand your tool belt.

[00:08:41] And then reason number three, this is an interesting one, and bear with me, I'm gonna ruffle some feathers here. I think there's a real concern about job security. I think a lot of senior developers and maybe mid-tier developers are. Retaliating. They're very upset by what this means. What the success of vibe coding tooling means for their future.

[00:09:03] I'm seeing a lot of anger real anger on Reddit and X when somebody showcases something they worked on and people will say, oh yeah, talk to me and. A month's time when the thing comes crashing down and you're crying at my shores and I'm like, whoa, relax. The guy built a project. So I think there's little bit of nervousness and it's causing some animosity towards the concept of vibe coding.

[00:09:27] my response to that is WordPress, remember WordPress? Once upon a time, building a website was a real engineering feat. And nowAiderys we have WordPress and Wix and Squarespace, and that's at the content management system level. Even as a programmer, we have tools that make life so much easier than they used to react and tailwind.

[00:09:50] and in fact I was a web developer when a lot of these content management systems came out and started getting popular. And I do remember that being terrifying for For web developers who had to study this stuff in computer science and along comes these systems that allow people to drag and drop widgets on a website and click a button and it's published to the web.

[00:10:08] but now we have WordPress developers and we still have developer developers. It's just the tooling made life a little bit simpler. So what I would say to the people who. Maybe are in touch enough with their emotions to accept that they're concerned about job security. I would say to them, the tooling just got better.

[00:10:27] Life as a programmer just got easier. Use it as a tool. It will continue to be used as a tool. I don't know the future. I don't know if there will come a point where simply A CEO can use this to generate everything from nuts to bolts for now, hang tight and use the tool. It's a good tool.


[00:10:45] Now finally, Andre Carpathy the computer scientist co-founder of Open AI is the guy that coined the phrase vibe coding. So it's a legitimate phrase. It wasn't a meme phrase spawned by four chan.

[00:10:59] So I propose we steal it back.

[00:11:01] From those that give it a bad name.

[00:11:03] So vibe coding is using LLMs to generate code in your project. There are a bunch of flavors of it out there. There's websites out there, there's one called Lovable there's one called Rep. It. And there's one called Bolt New and a handful more and increasingly growing because of this whole marketing wave where you can just type into a website after you log in and pay a subscription what you want out of your project, you generate a website or a mobile app, click submit and it creates a scaffold.

[00:11:33] And then you can click on one of the elements in the page and you can say, move it to the left at a logo of somebody eating a burrito, We're not gonna be talking about those in this episode. You are presumably here because you are an engineer.

[00:11:45] Those would be the content management systems equivalent of vibe coding. Those would be like Drupal or Wix or Squarespace. And they don't lock you out totally. You can download your code and then modify it from there. But generally they're intended to be a one stop shop where you, tell it what you want on a website and it will build it and deploy it for you all.

[00:12:06] All in one turnkey solution.


[00:12:09] clearly, they give you less control over your project. Even those who have generated scaffolds of an entire project through things like lovable, downloaded the code and started to work from it locally, from there have complained saying it's they were better off if they'd have gone cursor from the start.

[00:12:26] So those projects these web and mobile app generator websites like Lovable Rept and Bolt, they're great for what they are, but they're not what we are gonna be covering here. We're gonna be covering ides, integrated development environments and plugins Now things have changed a fair bit recently, and I'm talking months. Just in the last couple months, things have really shifted. Everything has moved towards VS. Code Visual Studio Code and previously there were dedicated IDs.

[00:12:58] There was tab nine and continue Dev and Co. Cody. They were either dedicated IDs or there were plugins and a lot of them supported jet brains and whatnot. A lot of them used rag, RAG retrieval, augmented generation to index your code base. They don't really do that as commonly these days. And a lot of these older. Tools fell out of favor. Cody was really popular for a bit. Their continue dev was really popular. these projects are significantly less popular these days and there's really a handful of strong competitors.

[00:13:30] and this is risky of me to narrow it down because things are going to change again. By the time I launch this episode, it'll already be. Outdated and there will probably be some new defacto IDE or plugin, but we're gonna roll with this. Today is April 11th, 2025. These are the most popular vibe coding tools right now.

[00:13:51] Cursor, copilot, windsurf Cline, Roo Code, and Aider. All of them, but Aider are either a vs. Code fork, a fork of the Visual Studio Code Project, or a VS. Code extension, a plugin that you can drop into vs code.


[00:14:12] Now I'm just going to spoil it right now. My favorite is Roo Code.


[00:14:17] by the way, if I seem out of breath in this episode, it's because I'm recording it on a treadmill desk. I do everything on a treadmill desk. These days, all my podcasts, pre-research, my reading work, emails. I won't touch a keyboard unless I'm on a treadmill.

[00:14:32] I walk about 10 miles every day. It's the only way I can stay healthy with my busy schedule. I recommend it for everybody, whether you're studying machine learning or working on your projects. If you want to see my favorite walking desk setup, go to oc deve.com/walk, O-C-D-E-V-E l.com/walk.


[00:14:53] Now I'm just going to spoil it right now. My favorite is Roo Code. I've experimented with all of these fairly extensively and I like Roo Code the most. And I'll talk about that in a bit. the way I like to think of these they have personalities of their own. They're not that different from each other except for Aider, except for in maybe their monetization strategy, some of the capabilities that they offer. They used to be very different from each other. And picking one and sticking with it meant it was a big deal because you're locking yourself in.

[00:15:24] They used to be so different from each other primarily in the capabilities that they offered. Some of them were more agentic than others. age. Agentic means that the tool offers an agent, an AI agent, and an agent is something in the tool that allows it to operate more autonomously within your code base.

[00:15:43] if you tell it to look at a file and you say there's a bug the agent mode of one of these tools will allow it to look at what are the imports of that file. Okay? I'm gonna go into that import. I'm gonna open up a totally separate file, scan it,

[00:15:57] maybe realize that there's some upstream dependency. Okay? I'm actually gonna go. up to directories, and I'm gonna run a search command on that folder looking for something specific. Okay, I found it. Oh, it looks like you're missing this particular Python package or NPM dependency. I'm gonna suggest that we run a command and then you can click Yes, I accept, run the command, and so forth.

[00:16:17] That's the A agentic capabilities of these tools by contrast to what was previously the only way to interact with These early vibe coding prototypes was that it would suggest inline edits of only the open file that you're looking at. so you'll open up a file and you start typing and it will auto complete a line of code or even a block of code.

[00:16:39] And so that was the sort of early days So those are two different ways to interact with these tools. One is inline edits of a file it will auto complete. one way people use this quite sophisticated is you can write a comment saying the following function should do X, Y, and z.

[00:16:57] And then by the time you hit enter at the comment close, it will suggest a whole function for you. So I'm not denigrating the use of inline edits in these code AI tools. It is half of the value of using these tools. So one way you work with these is inline edits of an individual file and another way you work with it is the agentic tooling or the agent that these tools offer and some of the capabilities of these agents are really sophisticated.

[00:17:22] They They can browse through files based on dependencies and what it thinks it needs to look for. It can run commands in your terminal. If you give it permission,

[00:17:31] it can open up the browser. So if you're building a website, it can open up a containerized browser, that's sandboxed, so it's doesn't get access to your security stuff. and it will look at the results of its output and send that image snapshot to Claude 3.7, for example, come back and say yes or no.


[00:17:50] we achieved what we were trying to accomplish.

[00:17:52] And then there's CPS or model context protocol that one I'll talk about in the next episode on Advanced Code ai because that is a world of its own. Now, previously only a handful of these tools offered some of these capabilities of an agent. And previously, some of these tools didn't offer ag agentic capabilities at all.

[00:18:14] So for example, GitHub copilot took a really long time to, to catch up. They released one of the earliest most popular plugins, GitHub copilot. But it was only for inline editing or you can ask it questions and it could explain what's happening in the code base.

[00:18:31] That was great for developers who are new to the project and stuff, but it was very limited. All the while many of these other

[00:18:37] vibe coding tools started adding ag agentic capabilities.

[00:18:40] Now adays, all of these projects provide agentic capabilities. Most of their capabilities are on par with each other. They all provide inline edits. So what differentiates these tools from each other is a lot less than it used to be. So my recommendation would be to just trial and error. Try all of these tools.


[00:19:02] If you can and just see which one you prefer, but selecting a tool from the list of options today is significantly less consequential than it was a few months ago. They're keeping lockstep with each other. It's an arms race. And at this point, it's just a preference game. I really think the differentiator at this point between these tools is basically like a personality between the different tools.

[00:19:27] Similar to, this is the analogy I use, the personality difference of operating systems. So Windows, you know what I'm talking about. Windows has a character of its own, Mac has a personality. You think of the typical user of a Mac as a pistachio, fixed, geared biker in a cafe, riding React and Tailwind.

[00:19:49] You think of a Windows user as corporate, blah, blah, blah. You think of a Linux user as a total dweeb. And so I'm gonna use that analogy in presenting these tools and I'm gonna compare them to operating systems.

[00:20:02] So we'll start with cursor. Cursor is the most popular, hands down. It is the most used, most known, most popular code AI tool. and I compare it to Mac, it is the Mac motto is it just works or it used, I don't maybe that was some, something that was circulated on the internet.

[00:20:21] But that stuck with me. It just works. So Cursor just works. That's the thinking behind Cursor. It uses. really good models like Claude 3.7 and Gemini 2.5 Pro. It's got it's diffs really dialed in. that's something that's a concept when it comes to these tools it takes a while when a new model is introduced for the tool, to really dial in how that model prefers to apply code to your file. And this is a DING strategy. So some models work best after you make a request, please fix the bug in this file, return, the edited file in its entirety. And some other models work best when the tool tells the model to return.

[00:21:09] A diff like a fenced diff or a standard git diff and a diff is remove these lines and add these lines at lines number 29 to 103. And there are various other nuances that each model has. That the tools have to become acquainted with time before they really dial in the right way to structure a request of the model.

[00:21:33] Some tools like Ru, for example are much more just. Pioneer charge forward, move fast, and break things. Gemini 2.5 Pro just came out. Let's add it right now, day one, and we'll deal with the nuances of that model later. We'll iron them out through experience whereas some other tools like Cursor, only enables new models.

[00:21:57] once all of the kinks are ironed out. So Cursor just works. They tend to spend a lot of time working with each new model as they're released,


[00:22:07] ironing out the kinks before making that available to the user. Cursor is a VS. Code fork. So it's not a plugin, it is a fork of the original visual studio code base. And they did that because they wanted a lot more capabilities that the sort of sandboxed environment that VS code provides allowed them.

[00:22:28] they wanted to override certain characteristics of the IDE so that they had more control over the environment. To perform some of the age agentic capabilities they wanted to implement. Cursor is 20 bucks a month flat fee. And then if you go over a certain number of requests, you start getting charged.

[00:22:46] It gets complicated. Basically it's $20 a month for average usage, for your average developer using it a fair amount. Each day. And then if you're a real power user and you start going way beyond typical usage, then they start charging you in certain other ways, like per request or per token or something.

[00:23:06] You'll have to look up the nuances of the pricing if you intend to use Cursor as a power user. cursor is the most popular. If you look up Vibe Coding, if you look up Code AI and YouTube, you're gonna see the first 10 videos are gonna be cursor.


[00:23:19] Now Hot Take. I recommend you start with Cursor. I recommend you try it, see if you like it, and if you like it, roll with it. If you want to explore more advanced capabilities we'll discuss some alternative tools here. I do personally think that some of the other tools. I'm gonna cover are more advanced.

[00:23:38] I really believe that. A lot of people, push back when I say that, they say, cursor has everything you need. And I say, I don't know. Ruco just dropped Boomerang mode and all these things. I find that some of these other tools push the envelope a little bit more. They offer more capabilities as time goes on.

[00:23:53] And Cursor, I think personally likes to play it a little bit safer. And the upside there is it's gonna be. Tighter code, you're gonna have results that just work. You have to fiddle with it less. The downside is you get to experiment less, in my opinion.


[00:24:08] Okay, next up is windsurf and their pricing model is it looks like $15 starting and they have anoth another tier up for $60. a lot of these ides or plugins that have pricing models. is one of two options. One is either they charge one flat fee, and anything you do that goes beyond typical usage, they'll charge you per request or per number of tokens or something that's like cursors model.

[00:24:35] and others of them will charge you a flat fee. And if you want more, then you have to upgrade and that's what Windsurf does. what I've found personally is this lower tier fee, like $15 for windsurf is quite generous. I find that I don't go beyond the typical use case.

[00:24:54] And I use these tools quite extensively, so You don't have to worry too much that they're just trying to cap you to wet your appetite, and then you're gonna be charged through the nose for any realistic amount of use case.

[00:25:05] I think they try to keep it a little bit reasonable and if you are a nuts, so power user, then hey, you should be paying more. Windsurf is similar to Cursor. They're trying to make it, it just works. Tool. So I'm gonna also compare it to Mac ish. I've used it, I used it for exclusively for a while there, and then I moved on to Rue because I just liked it better.

[00:25:25] Windsurf, I don't have much to say about it, honestly. A lot of people love it. It's a little bit of an underdog, It is by code. It used to be called coded code's. Been in this code AI tool before Vibe coding. The phrase was invented I think before most of these other tools that I'm talking about here. So they've been around for a while. They kept up pace. But yeah, it has ag agentic capabilities and it has inline editing capabilities.

[00:25:47] It too is a vs. Code fork. So it's a whole IDE of its own. But that means less these days. It used to be that being a vs code fork meant you can't install vs code plugins. And I don't think that's true anymore. At least I've installed vs code plugins. I think in all of these cursor copilot and, and windsurf somebody, correct me if I'm wrong there, but anyway, it being a vs. Code fork I think is less consequential than it used to be,

[00:26:14] it's one of those, it just works attempts. I don't see it used nearly as much as I see cursor and some of these other tools. Check it out. I, unfortunately, I don't have enough to say about it, but. All I can say is it's just slightly less popular than some of the more popular options.

[00:26:28] Okay. GitHub Copilot is Windows, right? Naturally it's by Microsoft. And it operates like windows. It, the vi the catchphrase would be, it should just work. They do a great job marketing. When it works. I've had great success with copilot. I really have, I use it exclusively for a month.

[00:26:50] It's ag agentic capabilities. They integrate all of the newest, latest and greatest models, all the latest and greatest tools. But there's just always hiccups. I don't know what the deal is. There was a phase there for a whole week. Where it would just time out and it was spinner. And then there was another phase where it was like, generating slop code.

[00:27:10] I'm sorry if I'm ruffling feathers for anybody who loves copilot. I have just personally found that its capabilities are great. But it's, I have trouble with it. I sh I, I wrestle with it. I've struggled with copilot and I have seen people on the internet experiencing the same experiences.

[00:27:27] They have a $10 tier, very inexpensive to get, if you wanna just get started and see what it looks like they have a $40 tier for more power use ca usage. it used to be that they were. $10 per month for infinite usage. And so they were a very compelling competitor in this space because they were so inexpensive.

[00:27:47] The other thing that made them very compelling is that it's not a vs. Code fork. They own vs. Code vs code and GitHub copilot are both made by Microsoft. So what you had to do is download the insider's preview version of VS code, but that just meant that it was the next version to be released and enabled GitHub copilot, and it had all of the capabilities it needed because it was the IDE.

[00:28:14] So once upon a time, it was extremely compelling because you didn't have to download a fork. You had all the tools of VS code that you want all the. Third party packages you maybe want to install And copilot itself wasn't limited by the environment and it was dirt cheap. So a lot of people really liked it early on.

[00:28:31] But their recent pricing model is more competitive with the standard pricing model of its competitors like Cursor and Windsurf. And the limitations of these vs. Code forks are Like a cursor and windsurf are less than they used to be. So give it a shot. I just think of them like windows. Windows should just work. And what do you know, blue screen? That's copilot in my experience, the occasional blue screen One thing people do like about copilot is it's integrated into GitHub Code Spaces. Code Spaces is GitHub's online code editor, and you can run a space per GitHub project in the cloud. So let's say you have a website and it's a GitHub project. You can spin up a Dockerized environment on GitHub code spaces, so you don't have to install anything on local hosts.

[00:29:25] Let's say maybe you're running windows and you don't want to deal with WSL two. Or you just want a more repeatable environment. Somebody can join the project and run their own space, and they don't, you don't have to give them any setup instructions and so forth. GitHub copilot is integrated into code spaces, so for cloud development which I think is a really cool concept, and I think it has a bright future.

[00:29:46] GitHub copilot, I think, has a stronger footing than all of these other tools that's worth exploring if you want to. Explore cloud development. now we're entering into open source territory, Cline, C-L-I-N-E. Cline, I think of as Debian, or Debian, I don't know how you pronounce it.

[00:30:05] It's the foundational, defacto standard. Of the open source competitors sets the stage, so to speak but maybe moves not quite so fast as re code trying to dial in

[00:30:19] Functionality and model integration diff strategies and what and whatnot. Only when it works, when they have it dialed. And Cline has tended to push the envelope faster. Further than cursor and windsurf and copilot. So it was the frontier tool of vibe coding. And it's a plugin, it's not a vs. Code fork. So you can install this inside of VS code. And as I believe inside of cursor and copilot and windsurf.

[00:30:44] Which means you can compare it side by side with some of its alternatives.


[00:30:48] like I said, once upon a time, They were the frontier plugin. They were pushing the envelope, they were the scouts. They were trying new things. They were really exploratory. That is significantly less so today compared to Roo Code, which we'll talk about next.

[00:31:03] But they still are, I think, Quite the adventurous spirit.

[00:31:06] they were one of the early adopters of a ag agentic tooling and capabilities and model context protocols, which is in the next episode.

[00:31:15] Now, the thing with the open source models is because they're open source, they don't have a pricing tier. You don't pay $10 a month for a certain amount of requests. Instead, you bring your own model. BYOM, bring your own model. So what you do is you sign up for an API key on OpenAI or. Anthropic or Google Gemini, you sign up for an API key.

[00:31:40] You plug that into Kline settings

[00:31:44] and every request you make to the model of your choice. You will be charged for, specifically for that request. So you're interacting with your code file And it goes up and it comes down, it goes up to the API of the model provider like Anthropic, for example. If you're using Claude 3.7 sonnet and then the response comes down , it applies the code to your file, and this whole round trip cost you, let's say 4 cents. Okay, now you, you have a follow up.

[00:32:15] You say that didn't quite work. Can you try this other bug fixing strategy instead? And you click submit and it goes up with the entire context up until that point, and then comes back with a response appended to the entire context. So every request you send is. All the prior requests plus the new request.

[00:32:40] And that can get a little bit expensive with time. The longer you interact with one session of an agent and Cline and Roo Code and er all the open source ones. They've been doing their best to intelligently send only what's essential. For each request rather than the entire context of the running conversation.

[00:33:06] But they can only do so much. but they have built in certain strategies to prevent you from being charged too much. So the upside of Cline is as an open source project. They're able to move a little bit faster than some of these other tools, which have corporations and regulations.

[00:33:24] And the open source community is huge. lots of people contributing to these open source projects. So they're able to move faster and explore more. The downside is you're charged for every request. What does that look like in practice dollars wise? Me personally a standard day looks like about $5, two to $5, and I don't use code AI tools every day.

[00:33:48] So at the end of the month, I think I end up paying about $30. Some people who are very heavy power users, I've seen somebody say that they, paid about $2,000 in one month. So it just depends on you. It totally depends on your usage amount. One trick of the trade here is to use cursor as your primary IDE, with the Kline plugin installed.

[00:34:13] And to use Cursor as sort of your daily driver. Use cursor's agent and inline editing tooling within the limitations provided by the $20 per month fee. And once you've reached your cursor quota for the month, you start using your own API key inside of KLE.

[00:34:36] And that's a good way to keep costs low. Alternatively, if you find that the Kline tooling is more sophisticated than what Cursor provides, which I believe to be true, then you can use Kline for the more complex tasks. And you can use Cursor for the day-to-day bread and butter tasks, like editing a code file, fixing a bug, and you can use Cline for, refactoring a broad swath of files while calling a MCP to look up code retrieval from your rag, local embedding store and whatnot.

[00:35:10] Okay. And then finally ro code, ROO code. It used to be called Ro Cline because it was actually a fork of Cline. I don't know exactly why they forked Cline. I don't know if they found that Cline was moving to slow or they, they weren't implementing the types of features they were hoping for.

[00:35:28] But they forked Cline and it was called Ru Cline. And they had a release all the time, like every other day. And all the while Cline would have a release, like every week or every month or something. So Roo Code really started pushing the envelope. And I think you will find that of these tools.

[00:35:46] Roo Code is definitely the envelope pusher. Now as far as operating system comparisons go, we got cursors Mac Os windsurf is in that category ish. Two copilot is Windows. Cline is Debian. I would say Roo Code is Ubuntu. Maybe Maybe my understanding of Linux distributions is a little bit marred, but I understand Debian to be a little bit more stable and calm and at least in the early days, Ubuntu was really pushing the envelope with gooey changes and apps they were adding and then snap and all these things. So Roo Code is a move fast and break things principled plugin.

[00:36:23] Similar to kle. It's a plugin, so you can plug it in alongside vs. Code And they add features. It's crazy. I'm part of their discord and you get the at every one and I get that every single day, every day. And these aren't just like bug fixes. These are brand new concepts in the domain Of vibe coding. They are building and building. Holy cow. They go so fast. And the upside of that speed is you are a pioneer. If you're using Roo Code, you are truly a pioneer in using AI to program because the features they add Are exploratory, they are trying new things. Much of these new concepts with great success like boomerang mode I'll talk about in a bit.

[00:37:12] The downside is they tend, I'm sorry, Roo Code, if you're listening I think they tend to be less careful. When Google, Gemini 2.5 Pro Model got released they just implemented it, integrated it right into the package, get going, you can try it right now. And it took a long while for the other tools to add Gemini. When I started using Gemini and root code, it didn't work at all.

[00:37:35] so there's a price to be paid for the speed, it only took a couple days before they ironed out the kinks, and I think it took a little bit more time than that for the other tools to integrate it in the first place. But if you use rue code, you're signing up to be part of the experiment in a sense.

[00:37:53] The upside is you're staying ahead of the curve. And the downside is there may be some speed bumps. Now Roo Code, like I said, it's a power tool. It is the biggest of the power tools of all of these tools. And as such, it has a fairly sophisticated settings page. When you click the settings button, you can tweak dials and knobs significantly more than you can with the other tools.

[00:38:15] some of these settings are really cool. For example, Gemini 2.5 Pro. It has a very large context window. I think it's 1 million compared to all the other models like Claude 3.7 and the GPT series. And so you can stuff a lot more context into your chats than you can with those other tools.

[00:38:34] and there's a setting where you can specify how many lines of code the model should read of a file to add to the context. and with Claude, 3.7, I set that to about 500. That's the default. And with Gemini 2.5 Pro, I just disable the feature, read the entire file.

[00:38:49] Cline and Roo Code. I don't know who pioneered this. It actually might've been er in fact have this concept of different modes with which you're interacting with the model. And the two most common are architect and code.

[00:39:02] I will talk about that in the next episode, but I'll give you a slice here. Architect mode is for telling the model to think deeply about a problem. You basically think of it as a senior software engineer. Thinking through the game plan and optimal strategy for tackling a particular problem and code mode just does it.

[00:39:20] It's the thing that builds the code. and so it's a very common strategy to have the mode start in architect mode and you tell it what to do it will think through a strategy, a game plan, and it will flip. To code mode when it's ready to implement it, and then code mode will actually implement the details.

[00:39:38] if I'm not mistaken, Cline only offers architect and code where Ru offers any number of modes including custom modes that you can define yourself. And it comes outta the box with ask Architect. Code and debug. And so if you're fixing a bug, you want to use the debug mode. And if you just have a question you switch it to ask mode and you can define your own custom modes.

[00:40:03] And they have one sample custom mode for download on their website. Docs Roo Code and it's called Boomerang mode. It is my favorite feature of all the code AI tools. Bar none, period. I'm not gonna talk about it here. It is a very powerful tool. If you want to know what that tool is, join me in the next episode.

[00:40:26] So that's just an example of The way in which these different projects operate. Root code is the move fast and break things, explore new territories try new experiments and stuff. And I like that. I personally like that. I use Linux. I'm on Ubuntu right now. I'm recording this. I like to tinker if I'm gonna be using something extensively. As my day job, I want it to be as powerful and limitless as possible. As a programmer, I use jet brains rather than vs code because Jet Brains has more bells and whistles and dials and knobs. It's just super, power tool, IDE, whereas vs.

[00:41:01] Code is meant to be like a notepad plus plus. plus. Now these days the entirety of the code AI world is en vs code. So I rock both editors open at one time jet brains, for when I, the human is programming and vs.

[00:41:14] Code plus ru for when I'm having the AI agent drive. but hey, that's not for everybody. Not everybody wants too many options. They just want something that works. And so that's why I recommend you try all these tools and just see what you prefer. And then finally we have ER, A-I-D-E-R ER's an odd duck. It is a unique vibe coding tool. if you had to think of it as an operating system, it maybe it would be gen two. I don't know if that's even still around, but it was like the most customizable Linux distribution on the planet.

[00:41:47] So much so you had to compile it from scratch and it was not for the faint of heart. that's too much of a comparison. Aer is not that bad. But it's CLI only, it only works on terminal. It is not an IDE and it is not a plugin.

[00:42:00] It is a command line script that only works inside of your terminal. And to use it and to configure it, you create these configuration files where you modify the settings to be just so for certain projects. And all of the tools that I mentioned previously, they have this concept called snapshots or checkpoints.

[00:42:20] Where each step of the chat session will save a snapshot and you can roll back to those things. What ER does is it get, commits everything. It does every round trip to the model. It will get committed because it doesn't have anything else it can work with, since it's only a CLI tool and it's up to you to look at the get diffs and see the changes it's made, you can roll them back as a command inside of the CLI.

[00:42:45] You select which model and you select the ding strategy and various other options inside of a configuration file.

[00:42:53] And there's one thing that they do that's very fascinating They're very careful with the number of tokens that are sent. To the model to, because just Roo Code and Cline, this being an open source project without a pricing structure that you could subscribe to it depends on you bringing your own model, which means you're gonna be charged for every token you send and receive.

[00:43:12] And they spent a lot of time dialing in a strategy that prevents you from sending too many tokens when the model might need a lot of context about your project.

[00:43:24] It will send up, what is it called now?


[00:43:27] a get repo map. So it has a definition of the most salient parts of your project without the body of those things. So like a class definition and its member methods without submitting the actual definition of those methods. So they have a very clever system of reducing the amount of tokens that you use.

[00:43:48] Now, it used to be that was one of the most, if not the most pioneering of the tools. But I think Rue Code took that mantle with time, and I think Aider has stabilized and calmed down a little bit. They run a leaderboard on their website And I'll link it in the show, this is the leaderboard to follow.

[00:44:07] If you want to know what's the best model to use at any given time, because these LLMs are constantly leapfrogging each other Every month or sometimes every week, and it's not always that a new model is released, sometimes an improvement on an existing model is made.

[00:44:24] Claude does that a lot. Claude 3.5 had different versions of 3.5, and then now they have Claude 3.7. And as I understand, they're gonna continue to version that and improve upon it. That leaderboard on ER's website. they have a system a set of tests they run outside of the standardized coding benchmarks that are used when these models release.

[00:44:51] Their own benchmark results on their website. So Claude will come out with their own benchmark results compared to OpenAI, compared to Gemini. And some people will see those benchmark results and think I know a benchmark is a benchmark, but I'd like to see A more Switzerland benchmark ran across these models and er has, that is the defacto leader board. For in the wild code benchmarking. And when I say in the wild they have these tests they run that are intended to be more practical as opposed to maybe interview questions that some of the standard coding benchmarks are testing.

[00:45:28] They have a suite of tests that are more practically focused. Real life coding scenarios, And that was important for a long time.

[00:45:37] They were the first tool to implement any one model And it's really cool. They dog food their own tool. So they use ER to write the integration of a new model into er and they'll, every time they push out a release, they'll have at the bottom of their release notes how much of that release was written by AI versus requiring human oversight.

[00:46:00] Now when would you use er. Compared to some of these other tools, what I say is always have ER installed anyway. Just like in an operating system, you need ACL I. You need a terminal no matter what. ER comes in handy in odd times. The one thing Aider's really good at is just precision. Just really dialed correct code while keeping the context window minimal. So as not to bloat the model and confuse it. Sometimes you send a giant context window up to this model. And it can lose the plot a little bit on what it's trying to do.


[00:46:39] ER's really good. It's almost an exacto knife. It's really good at making tiny surgical precision cuts to your code. so I use er when one of the tools isn't getting it. Roo Code is being a little too sloppy, is moving fast and breaking things. And I'm like, no, this is.

[00:46:57] algorithmic fidelity is important. The other thing too is as you tend to experiment with these different tools Aider will always be your backup plan Because it's there in the CLI, it's not a, extension. You don't have to worry about which IDE you're using And because it's a bring your own model tool rather than a subscription based system you don't have to worry about the fact that you have it installed. You'll just use it when you need it.


[00:47:24] Okay, so here is my hot take on which tool you should use. I would say if you haven't used any of them yet, try cursor.

[00:47:32] Start there. If you've used cursor and you want to start experimenting with alternatives you might as well try copilot and windsurf since you're in the subscription model territory. Decide which of the subscription model tools you want to use because

[00:47:48] what you do next is you install one of the open source tools inside of your subscription based tool. So cursor, copilot, or windsurf. Experiment with all three and see which one you prefer. I have a feeling it's gonna be cursor and then inside of that, install Kline or Roo Code Kline, if you don't want to mess with it too much, You're okay with some sane defaults, some slow moving, calm stability. And Roo Code. If you want to be a pioneer, move fast and break things

[00:48:22] and keep up with the latest and greatest in advancements. And then on top of that, just install Aider for now and use it for a highly precise surgical tasks where accuracy is of the essence and keep it on hand for. A backup tool one way in which I've used ER is that one of these tools didn't implement the latest and greatest model, but er did. So it's always handy to have a round.

[00:48:48] So cursor, copilot, or windsurf for your bread and butter tasks, your day to day inline edits of the code file or agentic tooling for simpler tasks, on blast. Kle or Roo Code inside of that for much more sophisticated, changes or to use after you've hit your quota from your subscription and eight or on hand for your surgical cuts.


[00:49:19] Now I'll talk about which models to use and the architect code mode. In the next episode, I actually rerecorded this episode. To pack in more details about the. Vibe coding tools themselves. So I'm gonna punt the models to the next episode, and in the next episode I'll also talk about the different modes, architect code, boomerang and model context protocol, MCP, the very powerful tool local models and some of the more advanced stuff in in vibe coding.

[00:49:50] There's one more thing you want to keep an eye out for. Google recently, and I'm talking brand new, recently started catching up. Previously they were a laughing stock. Their models were nowhere competitive. To Claude, especially Claude 3.7 was the go-to model for the longest time, and Gemini 2.5 Pro just released and it is incredible.

[00:50:12] It's the top in DER's leaderboard. It's a thinking model and a coding model, so you can use it for architect and code mode. It has an enormous context window. And I definitely don't wanna leave the episode before I say this. Currently Gemini 2.5 Pro Experimental 0 3 25.

[00:50:34] Okay, I'm gonna say that again 'cause I'll tell you wide in a bit. Gemini 2.5 Pro experimental 0 3 25. That model is free to use, which means you can use Cline or root code or er ad nauseum without incurring any cost with a giant context window. And in. Credible results that may change.

[00:50:56] Now they do have a paid version of the very same model by the name of Gemini 2.5 Pro Preview, which eventually I think will just be called Gemini two 2.5 Pro. And that is a paid model. So when you add the model to. Your vibe coding tool. Make sure it is the experimental 0 3 25 model, not the preview model, or you'll get charged out the nose.

[00:51:24] but because the experimental model is free right now, you can really just blast through your code projects without having to worry about cost in terms of the bring your own model paradigm. And they just added a. A new tool, a new website, and it's a vibe coding tool.

[00:51:40] It's, I think it's probably more similar to, to lovable that I mentioned early in the episode, a website for building websites, a website for building mobile apps than it is to any one of these tools, these plugins to VS code. But it is a very fully end to end experience where you can tell it to build something.

[00:52:00] And on top of that. Beyond lovable and replicate and bolt, it has baked in tooling for image generation and video generation and voice generation and everything you might need. For a company, like a whole company, not just the code of a web app. I haven't gotten to try it yet, but that's something I encourage you to explore and just see what it's all about because people are ranting and raving about this thing.

[00:52:27] It looks very potent. And then one thing I did forget to, to mention in this episode, if you're using one of the bring your own model tools the models that you are going to be choosing from, they will change Over time, very rapidly.

[00:52:42] At any given time one company takes the lead. it was Claude 3.5 then it was actually deep seek. And then after that it was Claude 3.7, and now it's Gemini Pro. And this all happened in the course of three months. So signing up for an API key for all of these different models what you typically do is.

[00:53:01] You don't just sign up for an API key and you get charged at the end of the month. Instead, you typically load these API keys, you add $20 that you can drain from and then you have to fill that up again when it's done well. If if you put $20 on anthropic and $20 on OpenAI, and $20 on deep seek.

[00:53:20] And you've only used $2 over here and $7 over here, you're gonna, you're gonna run outta money fast. So there's a project called Open Router and you give them your credit card and you top off the $20 and then you choose inside of Cline or root code you choose instead of Gemini Or Claude, you choose Open Router, then it comes up with a second dropdown, and then you choose Claude or Gemini Open Router will then fan out your requests, so you're only paying in one location and they handle connecting to two to new models as they become available. And that also means, as brand new models, some totally new company enters the scene. You don't have to sign up on that website and enter your credit card. You're just gonna interface with one company. It's Open router, and they take care of where the requests are sent and how much you are charged as a result. And so Open Router is the preferred method of interfacing with the Bring your own model.

[00:54:22] And it'll save you some money and it will allow you to experiment with all sorts of different models without having to sign up for all sorts of different API keys. So there you have it. Vibe coding in a nutshell, the tools.

[00:54:34] And the next episode, we will dive into more advanced techniques.

